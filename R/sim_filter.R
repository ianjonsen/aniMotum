##' @title Filter `simfit` simulations
##' 
##' @description This function calculates the similarity between the simulations
##' generated by `simfit` and the observed path used in the `ssm` fit,
##' and returns a `simfit` object containing the most similar tracks based on
##' a user specified quantile.
##' 
##' @param trs a `simfit` object
##' @param keep the quantile of flag values to retain
##' @param flag the similarity flag method (see details)
##' 
##' @details
##' * `flag = 1` will use an index based on Hazen (2017)
##' * `flag = 2` (the default) will use a custom index
##' 
##' @return a `simfit` object containing the filtered paths
##' 
##' 
##' @examples
##' ## fit crw model to Argos LS data
##' fit <- fit_ssm(sese1, vmax = 4, model = "crw", time.step = 24)
##' 
##' ## generate 10 simulated paths from ssm fit
##' trs <- simfit(fit, what = "predicted", reps = 10)
##' 
##' ## filter simulations and keep paths in top 25% of flag values
##' trs_f <- sim_filter(trs, keep = .33, flag = 2)
##' 
##' ## compare unfiltered and filtered simulated paths
##' plot(trs) | plot(trs_f)
##' 
##' @references Hazen et al. (2017) WhaleWatch: a dynamic management tool for 
##' predicting blue whale density in the California Current J. Appl. Ecol. 54: 1415-1428
##' [https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2664.12820](https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2664.12820)
##' 
##' @importFrom dplyr group_by ungroup select "%>%" filter
##' @importFrom tidyr nest unnest
##' @importFrom stats quantile
##' @export
##' @md

sim_filter <- function(trs, keep = .25, flag = 2){

  stopifnot("trs must be an `simfit` object" = inherits(trs, "simfit"))
  
  # filter based on similarity to original path
  # apply the similarity flag function to each simulated track
  # unnest the simfit object to extract the simulations
  trs_df <- trs %>% unnest(cols = c(sims))
  
  # can't figure out a map-type way to do this...
  # loop instead?
  trs_df$flg <- NA
  for (i in 1:length(unique(trs_df$id))){
    
    foo <- trs_df %>% filter(id == unique(trs_df$id)[i])
    
    if (requireNamespace("purrr", quietly = TRUE)) {
      foo <- purrr::map_df(split(foo, foo$rep),
                           function(.x) {
                             .x["flg"] <- similarity_flag(
                               track = foo %>% filter(rep == 0),
                               sim_track = .x,
                               flag = flag
                             )
                             .x
                           })
    } else {
      foo <- lapply(split(foo, foo$rep), function(.x) {
        .x["flg"] <- similarity_flag(
          track = foo %>% filter(rep == 0),
          sim_track = .x,
          flag = flag
        )
        .x
      }) %>%
        do.call(rbind, .)
    }
    trs_df$flg[trs_df$id == unique(trs_df$id)[i]] <- foo$flg
  }
  
  # filter based on user defined 'keep'
  # flag values can be positive or negative but will be centered around 0 (perfect match)
  # select only those tracks that have a flag value in the top 'keep' of flag values
  trs_df <- trs_df %>%
    group_by(id) %>%
    filter(abs(flg) < quantile(abs(flg), keep)) %>%
    ungroup()
  
  # format for foieGras output
  trs_filt <- trs_df %>% select(-flg) %>% nest(sims = c(rep, date, lon, lat, x, y)) # drop flag column
  class(trs_filt) <- append(class(trs)[1:2], class(trs_filt))
  return(trs_filt)
}
